{"version":3,"sources":["../src/client.ts","../src/hooks/useMCP.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import type { LLMConfig } from \"./types\";\n\nexport class LLMClient {\n  private config: LLMConfig;\n\n  constructor(config: LLMConfig) {\n    this.config = config;\n  }\n\n  async chat(messages: Array<{ role: string; content: string }>) {\n    const headers: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      ...this.config.headers,\n    };\n\n    if (this.config.apiKey) {\n      headers[\"Authorization\"] = `Bearer ${this.config.apiKey}`;\n    }\n\n    const response = await fetch(this.config.url, {\n      method: \"POST\",\n      headers,\n      body: JSON.stringify({\n        model: this.config.model,\n        messages,\n        stream: false,\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n\n    return await response.json();\n  }\n}\n\n// Pre-configured clients for common providers\nexport const createOllamaClient = (model = \"llama3.2:3b\") => {\n  return new LLMClient({\n    url: \"http://localhost:11434/api/chat\",\n    model,\n  });\n};\n\nexport const createOpenAIClient = (apiKey: string, model = \"gpt-3.5-turbo\") => {\n  return new LLMClient({\n    url: \"https://api.openai.com/v1/chat/completions\",\n    model,\n    apiKey,\n  });\n};\n\nexport const createAnthropicClient = (\n  apiKey: string,\n  model = \"claude-3-sonnet-20240229\"\n) => {\n  return new LLMClient({\n    url: \"https://api.anthropic.com/v1/messages\",\n    model,\n    apiKey,\n    headers: {\n      \"anthropic-version\": \"2023-06-01\",\n    },\n  });\n};\n","import { useState, useEffect } from \"react\";\nimport { Client } from \"@modelcontextprotocol/sdk/client/index.js\";\nimport { StdioClientTransport } from \"@modelcontextprotocol/sdk/client/stdio.js\";\nimport type { MCPResponse } from \"../types\";\n\nexport interface MCPHookResult {\n  isConnected: boolean;\n  loading: boolean;\n  readResource: (uri: string) => Promise<MCPResponse>;\n  callTool: (name: string) => Promise<MCPResponse>;\n}\n\nexport function useMCP(): MCPHookResult {\n  const [client, setClient] = useState<Client | null>(null);\n  const [isConnected, setIsConnected] = useState(false);\n  const [loading, setLoading] = useState(false);\n\n  useEffect(() => {\n    const initClient = async () => {\n      const mcpClient = new Client({\n        name: \"react-mcp-client\",\n        version: \"1.0.0\",\n      });\n\n      const transport = new StdioClientTransport({\n        command: \"npx\",\n        args: [\"tsx\", \"mcp_server.ts\"],\n      });\n\n      try {\n        await mcpClient.connect(transport);\n        setClient(mcpClient);\n        setIsConnected(true);\n      } catch (error) {\n        console.error(\"Error connecting to MCP server:\", error);\n      }\n    };\n\n    initClient();\n\n    return () => {\n      if (client) {\n        client.close();\n      }\n    };\n  }, []);\n\n  const readResource = async (uri: string): Promise<MCPResponse> => {\n    if (!client) throw new Error(\"MCP client not connected\");\n\n    setLoading(true);\n    try {\n      const resource = await client.readResource({ uri });\n      return {\n        type: \"resource\",\n        content: resource.contents[0].text,\n      };\n    } catch (error) {\n      return {\n        type: \"resource\",\n        content: \"\",\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      };\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  function ensureString(val: unknown): string {\n    return typeof val === \"string\" ? val : JSON.stringify(val ?? \"\");\n  }\n\n  const callTool = async (name: string): Promise<MCPResponse> => {\n    if (!client) throw new Error(\"MCP client not connected\");\n\n    setLoading(true);\n    try {\n      const result: any = await client.callTool({ name });\n      let toolText = \"\";\n      if (Array.isArray(result.content) && result.content.length > 0) {\n        const val = result.content[0].text;\n        toolText = typeof val === \"string\" ? val : JSON.stringify(val ?? \"\");\n      }\n      return {\n        type: \"tool\",\n        content: toolText,\n      };\n    } catch (error) {\n      return {\n        type: \"tool\",\n        content: \"\",\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      };\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return {\n    isConnected,\n    loading,\n    readResource,\n    callTool,\n  };\n}\n"]}